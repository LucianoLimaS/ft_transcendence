<html>

<head>
    <meta charset="UTF-8">
    <title>Pong Cl√°ssico</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000;
            font-family: 'Press Start 2P', cursive;
        }

        #gameCanvas {
            border: 2px solid #fff;
        }

        #countdown {
            position: absolute;
            color: #fff;
            font-size: 48px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .players {
            color: #fff;
            display: flex;
            justify-content: space-between;
            width: 800px;
            margin-bottom: 20px;
        }

        #winner {
            position: absolute;
            color: #fff;
            font-size: 32px;
            text-align: center;
            display: none;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 2px solid #fff;
        }

        #pointCountdown {
            position: absolute;
            color: #fff;
            font-size: 48px;
            display: none;
            justify-content: center;
            align-items: center;
        }

        #menu {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 2px solid #fff;
            color: #fff;
            font-size: 20px;
            display: flex;
            flex-direction: column;
            /* Itens do menu na vertical */
            z-index: 1;
            /* Garante que o menu fica por cima do canvas */
            max-width: 400px;
        }

        #difficulty {
            display: none;
            /* Esconde as op√ß√µes de dificuldade inicialmente */
            margin-top: 10px;
            /* Espa√ßamento entre o modo de jogo e as dificuldades */
        }

        .menu-button {
            background-color: #fff;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 5px 0;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
        }

        span {
            font-size: 12px;
            text-align: justify;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>

<body>
    <div id="menu">
        <button class="menu-button" id="singleplayerBtn">Single Player</button>
        <button class="menu-button" id="multiplayerBtn">Multiplayer</button>
        <div id="difficulty">
            <button class="menu-button" id="easyBtn">F√°cil</button>
            <button class="menu-button" id="mediumBtn">M√©dio</button>
            <button class="menu-button" id="hardBtn">Dif√≠cil</button>
            <br>
            <br>
            <span>As op√ß√µes F√°cil e M√©dio cumprem os requisitos de ia do PDF, a op√ß√£o Dif√≠cil deixei para ficar mais
                divertido o jogo.</span>
        </div>
    </div>
    <div class="players">
        <div>Player 1: <span id="p1Lives">üêÑüêÑüêÑ</span></div>
        <div>Player 2: <span id="p2Lives">üêÑüêÑüêÑ</span></div>
    </div>
    <div id="countdown"></div>
    <div id="pointCountdown"></div>
    <div id="winner">
        <p id="winnerText"></p>
        <button id="restartBtn">Reiniciar</button>
        <button id="menuBtn">Menu</button>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        // Obt√©m o elemento canvas do DOM
        const canvas = document.getElementById('gameCanvas');

        // Fun√ß√£o para redimensionar o canvas com base na propor√ß√£o 2:1
        function resizeCanvas() {
            const aspectRatio = 2 / 1; // Propor√ß√£o 2:1
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            let canvasWidth, canvasHeight;

            // Ajusta o tamanho do canvas com base na propor√ß√£o da janela
            if (windowWidth / windowHeight > aspectRatio) {
                canvasHeight = windowHeight * 0.8; // 80% da altura da janela
                canvasWidth = canvasHeight * aspectRatio;
            } else {
                canvasWidth = windowWidth * 0.8; // 80% da largura da janela
                canvasHeight = canvasWidth / aspectRatio;
            }

            // Define a largura e altura do canvas
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        }

        // Chama a fun√ß√£o para redimensionar o canvas inicialmente e quando a janela for redimensionada
        window.addEventListener('resize', resizeCanvas);

        resizeCanvas(); // Chama inicialmente para configurar o tamanho

        // Obt√©m o contexto de renderiza√ß√£o 2D do canvas
        const ctx = canvas.getContext('2d');
        // Elemento de contagem regressiva
        const countdownElement = document.getElementById('countdown');
        // Elemento de contagem regressiva para pontos
        const pointCountdownElement = document.getElementById('pointCountdown');
        // Elemento que exibe o vencedor
        const winnerElement = document.getElementById('winner');
        // Elemento que exibe as vidas do Player 1
        const p1LivesElement = document.getElementById('p1Lives');
        // Elemento que exibe as vidas do Player 2
        const p2LivesElement = document.getElementById('p2Lives');
        // Bot√£o para iniciar o modo single player
        const singleplayerBtn = document.getElementById('singleplayerBtn');
        // Bot√£o para iniciar o modo multiplayer
        const multiplayerBtn = document.getElementById('multiplayerBtn');
        // Div que cont√©m as op√ß√µes de dificuldade
        const difficultyDiv = document.getElementById('difficulty');
        // Bot√£o para selecionar a dificuldade f√°cil
        const easyBtn = document.getElementById('easyBtn');
        // Bot√£o para selecionar a dificuldade m√©dia
        const mediumBtn = document.getElementById('mediumBtn');
        // Bot√£o para selecionar a dificuldade dif√≠cil
        const hardBtn = document.getElementById('hardBtn');
        // Bot√£o para reiniciar o jogo
        const restartBtn = document.getElementById('restartBtn');
        // Bot√£o para voltar ao menu
        const menuBtn = document.getElementById('menuBtn');
        // Elemento que exibe o texto do vencedor
        const winnerText = document.getElementById('winnerText');
        // Elemento do menu principal
        const menu = document.getElementById('menu');

        // Vari√°vel para controlar se o jogo come√ßou
        let gameStarted = false;
        // Vari√°vel para controlar se o jogo terminou
        let gameEnded = false;
        // Vari√°vel para a contagem regressiva inicial
        let countdown = 3;
        // Vari√°vel para a contagem regressiva entre pontos
        let pointCountdown = 3;
        // Vari√°vel para controlar se a contagem regressiva de pontos est√° ativa
        let isPointCountdownActive = false;
        // Multiplicador de velocidade da bola
        let ballSpeedMultiplier = 1;
        // Vari√°vel para controlar o modo single player
        let singlePlayer = false;

        // Pontua√ß√£o m√°xima para vencer o jogo
        const maxScore = 3;
        // Velocidade inicial da bola
        const initialBallSpeed = 4;
        // Define uma velocidade m√°xima para a raquete da IA
        const maxAISpeed = 3.5;

        // Pontua√ß√£o do Player 1
        let leftScore = 0;
        // Pontua√ß√£o do Player 2
        let rightScore = 0;

        // Evento para o bot√£o de single player
        singleplayerBtn.addEventListener('click', () => {
            setSinglePlayer(true); // Define o modo single player
            difficultyDiv.style.display = 'block'; // Mostra as op√ß√µes de dificuldade
            singleplayerBtn.style.backgroundColor = 'red'; // Muda a cor do bot√£o para indicar sele√ß√£o
        });

        // Evento para o bot√£o de multiplayer
        multiplayerBtn.addEventListener('click', () => {
            setSinglePlayer(false); // Define o modo multiplayer
            menu.style.display = 'none'; // Esconde o menu
            startCountdown(); // Inicia a contagem regressiva para come√ßar o jogo
        });

        // Evento para o bot√£o de dificuldade f√°cil
        easyBtn.addEventListener('click', () => {
            setDifficulty('easy'); // Define a dificuldade como f√°cil
            startGameAfterDifficultySelection(); // Inicia o jogo ap√≥s a sele√ß√£o da dificuldade
        });

        // Evento para o bot√£o de dificuldade m√©dia
        mediumBtn.addEventListener('click', () => {
            setDifficulty('medium'); // Define a dificuldade como m√©dia
            startGameAfterDifficultySelection(); // Inicia o jogo ap√≥s a sele√ß√£o da dificuldade
        });

        // Evento para o bot√£o de dificuldade dif√≠cil
        hardBtn.addEventListener('click', () => {
            setDifficulty('hard'); // Define a dificuldade como dif√≠cil
            startGameAfterDifficultySelection(); // Inicia o jogo ap√≥s a sele√ß√£o da dificuldade
        });

        // Fun√ß√£o para reiniciar o jogo
        function resetGame() {
            gameStarted = false; // Define que o jogo n√£o come√ßou
            gameEnded = false; // Define que o jogo n√£o terminou
            countdown = 3; // Reinicia a contagem regressiva inicial
            pointCountdown = 3; // Reinicia a contagem regressiva entre pontos
            isPointCountdownActive = false; // Define que a contagem regressiva de pontos n√£o est√° ativa
            ballSpeedMultiplier = 1; // Reinicia o multiplicador de velocidade da bola
            leftScore = 0; // Reinicia a pontua√ß√£o do Player 1
            rightScore = 0; // Reinicia a pontua√ß√£o do Player 2
            ball.x = canvas.width / 2; // Define a posi√ß√£o inicial da bola no centro do canvas
            ball.y = canvas.height / 2; // Define a posi√ß√£o inicial da bola no centro do canvas
            ball.speedX = initialBallSpeed; // Define a velocidade inicial da bola no eixo X
            ball.speedY = initialBallSpeed; // Define a velocidade inicial da bola no eixo Y
            leftPaddle.y = initialPaddlePositions.left; // Define a posi√ß√£o inicial da raquete esquerda
            rightPaddle.y = initialPaddlePositions.right; // Define a posi√ß√£o inicial da raquete direita
            winnerElement.style.display = 'none'; // Esconde o elemento que exibe o vencedor
            p1LivesElement.textContent = 'üêÑ'.repeat(maxScore); // Reinicia as vidas do Player 1
            p2LivesElement.textContent = 'üêÑ'.repeat(maxScore); // Reinicia as vidas do Player 2
            if (singlePlayer) {
                menu.style.display = 'none'; // Esconde o menu se estiver no modo single player
            }
            countdownElement.style.display = 'flex'; // Mostra o elemento de contagem regressiva
            startCountdown(); // Inicia a contagem regressiva
        }

        // Evento para o bot√£o de reiniciar
        restartBtn.addEventListener('click', () => {
            resetGame(); // Reinicia o jogo
        });

        // Evento para o bot√£o de voltar ao menu
        menuBtn.addEventListener('click', () => {
            menu.style.display = 'flex'; // Mostra o menu
            difficultyDiv.style.display = 'none'; // Esconde as op√ß√µes de dificuldade
            winnerElement.style.display = 'none'; // Esconde o elemento que exibe o vencedor
            resetGame(); // Reinicia o jogo
        });

        // Fun√ß√£o para definir o modo single player
        function setSinglePlayer(enabled) {
            singlePlayer = enabled; // Define o modo single player
        }

        // Objeto que representa a bola
        const ball = {
            x: canvas.width / 2, // Posi√ß√£o inicial X da bola
            y: canvas.height / 2, // Posi√ß√£o inicial Y da bola
            radius: 10, // Raio da bola
            speedX: initialBallSpeed, // Velocidade inicial da bola no eixo X
            speedY: initialBallSpeed // Velocidade inicial da bola no eixo Y
        };

        // Altura da raquete
        const paddleHeight = 100;
        // Largura da raquete
        const paddleWidth = 10;
        // Posi√ß√µes iniciais das raquetes
        const initialPaddlePositions = {
            left: canvas.height / 2 - paddleHeight / 2, // Posi√ß√£o inicial da raquete esquerda
            right: canvas.height / 2 - paddleHeight / 2 // Posi√ß√£o inicial da raquete direita
        };

        // Objeto que representa a raquete esquerda
        const leftPaddle = {
            x: 0, // Posi√ß√£o X da raquete esquerda
            y: initialPaddlePositions.left // Posi√ß√£o Y inicial da raquete esquerda
        };

        // Objeto que representa a raquete direita (controlada pela IA)
        let rightPaddle = {
            x: canvas.width - paddleWidth, // Posi√ß√£o X da raquete direita
            y: initialPaddlePositions.right, // Posi√ß√£o Y inicial da raquete direita
            speed: 6, // Velocidade da raquete da IA
            state: 'WAITING', // Estados da IA: WAITING, REASONING, ACTING
            targetY: canvas.height / 2 - paddleHeight / 2, // Alvo da raquete
            reactionDistance: canvas.width / 3, // Dist√¢ncia para reagir √† bola
            uncertainty: paddleHeight / 4, // Incerteza na posi√ß√£o da raquete
            randomMoveInterval: 1000, // Intervalo para movimentos aleat√≥rios
            lastRandomMove: 0 // Tempo do √∫ltimo movimento aleat√≥rio
        };

        // N√≠veis de dificuldade para a IA
        const difficultyLevels = {
            easy: {
                speed: 2, // Velocidade baixa da raquete
                uncertainty: paddleHeight, // Incerteza m√°xima na posi√ß√£o da raquete
                reactionDistance: canvas.width / 8, // Reage muito tarde
                randomMoveInterval: 2000, // Movimentos aleat√≥rios frequentes
                predictionIterations: 100, // Poucas itera√ß√µes de previs√£o
                time: 1000 // Tempo de atualiza√ß√£o da IA em milissegundos
            },
            medium: {
                speed: 8, // Velocidade alta da raquete
                uncertainty: paddleHeight / 16, // M√≠nima incerteza na posi√ß√£o da raquete
                reactionDistance: canvas.width * 0.75, // Reage bem cedo
                randomMoveInterval: 500, // Movimentos aleat√≥rios menos frequentes
                predictionIterations: 5000, // Muitas itera√ß√µes de previs√£o
                time: 1000 // Tempo de atualiza√ß√£o da IA em milissegundos
            },
            hard: {
                speed: 8, // Velocidade alta da raquete
                uncertainty: paddleHeight / 16, // M√≠nima incerteza na posi√ß√£o da raquete
                reactionDistance: canvas.width * 0.75, // Reage bem cedo
                randomMoveInterval: 500, // Movimentos aleat√≥rios menos frequentes
                predictionIterations: 5000, // Muitas itera√ß√µes de previs√£o
                time: 1 // Tempo de atualiza√ß√£o da IA em milissegundos
            },
        };

        // Fun√ß√£o para definir a dificuldade do jogo
        function setDifficulty(level) {
            currentDifficulty = level; // Define a dificuldade atual
            const settings = difficultyLevels[level]; // Obt√©m as configura√ß√µes da dificuldade
            rightPaddle.speed = settings.speed; // Define a velocidade da raquete da IA
            rightPaddle.uncertainty = settings.uncertainty; // Define a incerteza da posi√ß√£o da raquete da IA
            rightPaddle.reactionDistance = settings.reactionDistance; // Define a dist√¢ncia de rea√ß√£o da IA
            rightPaddle.randomMoveInterval = settings.randomMoveInterval; // Define o intervalo de movimentos aleat√≥rios da IA
        }

        // Objeto para armazenar o estado das teclas pressionadas
        const keys = {};

        // Evento para detectar quando uma tecla √© pressionada
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true; // Marca a tecla como pressionada
        });

        // Evento para detectar quando uma tecla √© solta
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false; // Marca a tecla como n√£o pressionada
        });

        // Fun√ß√£o para iniciar a contagem regressiva
        function startCountdown() {
            countdownElement.textContent = countdown; // Define o texto da contagem regressiva

            const countdownInterval = setInterval(() => {
                countdown--; // Decrementa a contagem

                if (countdown <= 0) {
                    clearInterval(countdownInterval); // Limpa o intervalo quando a contagem chega a zero
                    countdownElement.style.display = 'none'; // Esconde o elemento de contagem regressiva
                    gameStarted = true; // Define que o jogo come√ßou
                    gameLoop(); // Inicia o loop do jogo
                } else {
                    countdownElement.textContent = countdown; // Atualiza o texto da contagem regressiva
                }
            }, 1000); // Intervalo de 1 segundo
        }

        // Fun√ß√£o para iniciar o jogo ap√≥s a sele√ß√£o da dificuldade
        function startGameAfterDifficultySelection() {
            menu.style.display = 'none'; // Esconde o menu principal
            startCountdown(); // Inicia a contagem regressiva
        }

        // Fun√ß√£o para atualizar as vidas dos jogadores
        function updateLives() {
            const remainingLivesP1 = 'üêÑ'.repeat(maxScore - rightScore); // Calcula as vidas restantes do Player 1
            const remainingLivesP2 = 'üêÑ'.repeat(maxScore - leftScore); // Calcula as vidas restantes do Player 2
            p1LivesElement.textContent = remainingLivesP1; // Atualiza o elemento de vidas do Player 1
            p2LivesElement.textContent = remainingLivesP2; // Atualiza o elemento de vidas do Player 2
        }

        // Fun√ß√£o para verificar se h√° um vencedor
        function checkWinner() {
            if (rightScore >= maxScore) { // Verifica se o Player 2 atingiu a pontua√ß√£o m√°xima
                gameEnded = true; // Define que o jogo terminou
                winnerElement.style.display = 'block'; // Mostra o elemento que exibe o vencedor
                winnerText.textContent = 'Player 2 Venceu! üèÜ'; // Define o texto dentro do par√°grafo
                return true; // Retorna verdadeiro indicando que h√° um vencedor
            } else if (leftScore >= maxScore) { // Verifica se o Player 1 atingiu a pontua√ß√£o m√°xima
                gameEnded = true; // Define que o jogo terminou
                winnerElement.style.display = 'block'; // Mostra o elemento que exibe o vencedor
                winnerText.textContent = 'Player 1 Venceu! üèÜ'; // Define o texto dentro do par√°grafo
                return true; // Retorna verdadeiro indicando que h√° um vencedor
            }
            return false; // Retorna falso indicando que n√£o h√° vencedor ainda
        }

        let lastAIUpdate = 0; // Vari√°vel para armazenar o tempo da √∫ltima atualiza√ß√£o da IA

        // Fun√ß√£o para mover a raquete da IA
        function aiMovePaddle() {
            const currentTime = Date.now(); // Obt√©m o tempo atual
            let time = difficultyLevels[currentDifficulty].time; // Obt√©m o tempo de atualiza√ß√£o da dificuldade atual

            // Verifica se passou o tempo necess√°rio desde a √∫ltima atualiza√ß√£o
            if (currentTime - lastAIUpdate >= time) {
                const settings = difficultyLevels[currentDifficulty]; // Obt√©m as configura√ß√µes da dificuldade atual

                // Se a bola est√° se movendo em dire√ß√£o √† raquete direita e est√° dentro da dist√¢ncia de rea√ß√£o
                if (ball.speedX > 0 && ball.x > rightPaddle.reactionDistance) {
                    rightPaddle.targetY = predictBallPosition(settings.predictionIterations, 0.01); // Prediz a posi√ß√£o da bola

                    // Adiciona incerteza na posi√ß√£o alvo da raquete (apenas nos modos f√°cil e m√©dio)
                    if (currentDifficulty !== 'hard') {
                        rightPaddle.targetY += (Math.random() - 0.5) * 2 * rightPaddle.uncertainty;
                    }
                } else {
                    // Movimentos aleat√≥rios enquanto espera
                    if (Date.now() - rightPaddle.lastRandomMove > rightPaddle.randomMoveInterval) {
                        rightPaddle.targetY = Math.random() * (canvas.height - paddleHeight); // Define um alvo aleat√≥rio
                        rightPaddle.lastRandomMove = Date.now(); // Atualiza o tempo do √∫ltimo movimento aleat√≥rio
                    }
                }
                lastAIUpdate = currentTime; // Atualiza o tempo da √∫ltima atualiza√ß√£o
            }

            // Move a raquete em dire√ß√£o ao alvo
            let dy = rightPaddle.targetY - rightPaddle.y; // Calcula a diferen√ßa entre a posi√ß√£o atual e o alvo
            let moveSpeed = Math.min(Math.abs(dy), rightPaddle.speed); // Calcula a velocidade de movimento
            rightPaddle.y += Math.sign(dy) * moveSpeed; // Move a raquete na dire√ß√£o do alvo

            // Garante que a raquete n√£o saia dos limites do canvas
            rightPaddle.y = Math.max(0, Math.min(rightPaddle.y, canvas.height - paddleHeight));
        }

        // Fun√ß√£o para prever a posi√ß√£o da bola
        function predictBallPosition(iterations, step) {
            let position = { x: ball.x, y: ball.y }; // Posi√ß√£o inicial da bola
            let velocity = { x: ball.speedX, y: ball.speedY }; // Velocidade inicial da bola

            for (let i = 0; i < iterations; i++) {
                position.x += velocity.x * step; // Atualiza a posi√ß√£o X da bola
                position.y += velocity.y * step; // Atualiza a posi√ß√£o Y da bola

                // Verifica colis√£o com as bordas superior e inferior
                if (position.y + ball.radius > canvas.height || position.y - ball.radius < 0) {
                    velocity.y *= -1; // Inverte a dire√ß√£o da velocidade Y
                }

                // Verifica colis√£o com a raquete direita
                if (position.x + ball.radius > canvas.width - paddleWidth) {
                    return position.y - paddleHeight / 2; // Retorna a posi√ß√£o Y de colis√£o
                }
            }

            // Retorna a posi√ß√£o Y atual se n√£o houver colis√£o prevista dentro das itera√ß√µes
            return position.y - paddleHeight / 2;
        }

        // Fun√ß√£o para mover as raquetes
        function movePaddles() {
            // Move a raquete esquerda para cima se a tecla 'W' estiver pressionada e a raquete n√£o estiver no topo
            if (keys['KeyW'] && leftPaddle.y > 0) {
                leftPaddle.y -= 7;
            }
            // Move a raquete esquerda para baixo se a tecla 'S' estiver pressionada e a raquete n√£o estiver na parte inferior
            if (keys['KeyS'] && leftPaddle.y < canvas.height - paddleHeight) {
                leftPaddle.y += 7;
            }

            if (!singlePlayer) { // Modo multiplayer
                // Move a raquete direita para cima se a tecla 'ArrowUp' estiver pressionada e a raquete n√£o estiver no topo
                if (keys['ArrowUp'] && rightPaddle.y > 0) {
                    rightPaddle.y -= 7;
                }
                // Move a raquete direita para baixo se a tecla 'ArrowDown' estiver pressionada e a raquete n√£o estiver na parte inferior
                if (keys['ArrowDown'] && rightPaddle.y < canvas.height - paddleHeight) {
                    rightPaddle.y += 7;
                }
            } else { // Modo single player (IA)
                aiMovePaddle(); // Move a raquete direita controlada pela IA
            }
        }

        function moveBall() {
            if (!gameStarted) return; // Se o jogo n√£o come√ßou, n√£o faz nada

            // Atualiza a posi√ß√£o da bola com base na velocidade
            ball.x += ball.speedX;
            ball.y += ball.speedY;

            // Verifica colis√£o com as bordas superior e inferior
            if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
                ball.speedY = -ball.speedY; // Inverte a dire√ß√£o da velocidade Y
            }

            let paddleHit = null; // Para rastrear qual raquete foi atingida

            // Verifica colis√£o com a raquete esquerda
            if (ball.x - ball.radius < leftPaddle.x + paddleWidth && ball.y > leftPaddle.y && ball.y < leftPaddle.y + paddleHeight) {
                paddleHit = leftPaddle;
                // Verifica colis√£o com a raquete direita
            } else if (ball.x + ball.radius > rightPaddle.x && ball.y > rightPaddle.y && ball.y < rightPaddle.y + paddleHeight) {
                paddleHit = rightPaddle;
            }

            // Se a bola colidiu com uma raquete
            if (paddleHit) {
                ball.speedX = -ball.speedX; // Inverte a dire√ß√£o da velocidade X

                // Aumenta a velocidade a cada batida
                let speedIncrement = 1.5; // Valor do incremento de velocidade
                let currentSpeed = Math.sqrt(ball.speedX * ball.speedX + ball.speedY * ball.speedY); // Calcula a velocidade atual
                let newSpeed = currentSpeed + speedIncrement; // Nova velocidade ap√≥s o incremento

                // Mant√©m a dire√ß√£o, mas altera a magnitude da velocidade
                ball.speedX = (ball.speedX / currentSpeed) * newSpeed;
                ball.speedY = (ball.speedY / currentSpeed) * newSpeed;
            }

            // Verifica se a bola passou pela borda direita
            if (ball.x + ball.radius > canvas.width) {
                leftScore++; // Incrementa a pontua√ß√£o do Player 1
                resetBall(); // Reinicia a posi√ß√£o da bola
                // Verifica se a bola passou pela borda esquerda
            } else if (ball.x - ball.radius < 0) {
                rightScore++; // Incrementa a pontua√ß√£o do Player 2
                resetBall(); // Reinicia a posi√ß√£o da bola
            }
        }

        // Fun√ß√£o para iniciar a contagem regressiva entre pontos
        function startPointCountdown() {
            isPointCountdownActive = true; // Define que a contagem regressiva de pontos est√° ativa
            pointCountdown = 3; // Reinicia a contagem regressiva entre pontos
            pointCountdownElement.style.display = 'flex'; // Mostra o elemento de contagem regressiva de pontos
            pointCountdownElement.textContent = pointCountdown; // Define o texto da contagem regressiva de pontos

            const pointCountdownInterval = setInterval(() => {
                pointCountdown--; // Decrementa a contagem

                if (pointCountdown <= 0) {
                    clearInterval(pointCountdownInterval); // Limpa o intervalo quando a contagem chega a zero
                    pointCountdownElement.style.display = 'none'; // Esconde o elemento de contagem regressiva de pontos
                    isPointCountdownActive = false; // Define que a contagem regressiva de pontos n√£o est√° ativa
                    gameStarted = true; // Define que o jogo come√ßou
                } else {
                    pointCountdownElement.textContent = pointCountdown; // Atualiza o texto da contagem regressiva de pontos
                }
            }, 1000); // Intervalo de 1 segundo
        }

        // Fun√ß√£o para reiniciar a posi√ß√£o da bola
        function resetBall() {
            ballSpeedMultiplier += 0.4; // Aumenta o multiplicador de velocidade da bola
            ball.x = canvas.width / 2; // Define a posi√ß√£o X inicial da bola no centro do canvas

            // Define a posi√ß√£o Y inicial da bola aleatoriamente dentro dos limites do canvas
            ball.y = Math.random() * (canvas.height - 2 * ball.radius) + ball.radius;

            ball.speedX = -ball.speedX; // Inverte a dire√ß√£o da velocidade X
            ball.speedY = (Math.random() > 0.5 ? initialBallSpeed : -initialBallSpeed) * ballSpeedMultiplier; // Define a velocidade Y inicial aleatoriamente
            ball.speedX = Math.sign(ball.speedX) * initialBallSpeed * ballSpeedMultiplier; // Define a velocidade X inicial com o multiplicador

            leftPaddle.y = initialPaddlePositions.left; // Reinicia a posi√ß√£o da raquete esquerda
            rightPaddle.y = initialPaddlePositions.right; // Reinicia a posi√ß√£o da raquete direita

            updateLives(); // Atualiza as vidas dos jogadores
            if (!checkWinner()) { // Verifica se h√° um vencedor
                gameStarted = false; // Define que o jogo n√£o come√ßou
                startPointCountdown(); // Inicia a contagem regressiva entre pontos
            }
        }

        // Fun√ß√£o para desenhar os elementos do jogo no canvas
        function draw() {
            // Limpa o canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Desenha a raquete esquerda
            ctx.fillStyle = '#fff';
            ctx.fillRect(leftPaddle.x, leftPaddle.y, paddleWidth, paddleHeight);

            // Desenha a raquete direita
            ctx.fillRect(rightPaddle.x, rightPaddle.y, paddleWidth, paddleHeight);

            // Desenha a bola
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();

            // Desenha a linha tracejada no meio do campo
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
        }

        // Fun√ß√£o principal do loop do jogo
        function gameLoop() {
            if (!gameEnded) { // Verifica se o jogo n√£o terminou
                if (!isPointCountdownActive) { // Verifica se a contagem regressiva entre pontos n√£o est√° ativa
                    movePaddles(); // Move as raquetes
                    moveBall(); // Move a bola
                }
                draw(); // Desenha os elementos do jogo
                requestAnimationFrame(gameLoop); // Chama a fun√ß√£o gameLoop novamente no pr√≥ximo frame
            }
        }

    </script>

    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</body>

</html>