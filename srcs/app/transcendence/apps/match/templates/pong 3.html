<html>

<head>
    <base href="https://websimcreation.com/pong/">
    <meta charset="UTF-8">
    <title>Pong Clássico</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000;
            font-family: 'Press Start 2P', cursive;
        }

        #gameCanvas {
            border: 2px solid #fff;
        }

        #countdown {
            position: absolute;
            color: #fff;
            font-size: 48px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .players {
            color: #fff;
            display: flex;
            justify-content: space-between;
            width: 800px;
            margin-bottom: 20px;
        }

        #winner {
            position: absolute;
            color: #fff;
            font-size: 32px;
            text-align: center;
            display: none;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 2px solid #fff;
        }

        #pointCountdown {
            position: absolute;
            color: #fff;
            font-size: 48px;
            display: none;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>

<body>
    <div class="players">
        <div>Player 1: <span id="p1Lives">🐄🐄🐄</span></div>
        <div>Player 2: <span id="p2Lives">🐄🐄🐄</span></div>
    </div>
    <div id="countdown"></div>
    <div id="pointCountdown"></div>
    <div id="winner"></div>
    <canvas id="gameCanvas" width="1400" height="700"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const countdownElement = document.getElementById('countdown');
        const pointCountdownElement = document.getElementById('pointCountdown');
        const winnerElement = document.getElementById('winner');
        const p1LivesElement = document.getElementById('p1Lives');
        const p2LivesElement = document.getElementById('p2Lives');

        let gameStarted = false;
        let gameEnded = false;
        let countdown = 3;
        let pointCountdown = 3;
        let isPointCountdownActive = false;
        let ballSpeedMultiplier = 1;
        let singlePlayer = false; // Variável para controlar o modo single player

        const maxScore = 3;
        const initialBallSpeed = 4;
        // Define uma velocidade máxima para a raquete da IA
        const maxAISpeed = 3.5; // Ajuste este valor para controlar a dificuldade

        let leftScore = 0;
        let rightScore = 0;

        // Função para definir o modo single player
        function setSinglePlayer(enabled) {
            singlePlayer = enabled;
        }

        const ball = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 10,
            speedX: initialBallSpeed,
            speedY: initialBallSpeed
        };

        const paddleHeight = 100;
        const paddleWidth = 10;
        const initialPaddlePositions = {
            left: canvas.height / 2 - paddleHeight / 2,
            right: canvas.height / 2 - paddleHeight / 2
        };

        const leftPaddle = {
            x: 0,
            y: initialPaddlePositions.left
        };

        let rightPaddle = {
            x: canvas.width - paddleWidth,
            y: initialPaddlePositions.right,
            speed: 6, // Velocidade da raquete da IA
            state: 'WAITING', // Estados da IA: WAITING, REASONING, ACTING
            targetY: canvas.height / 2 - paddleHeight / 2, // Alvo da raquete
            reactionDistance: canvas.width / 3, // Distância para reagir à bola
            uncertainty: paddleHeight / 4, // Incerteza na posição da raquete
            randomMoveInterval: 1000, // Intervalo para movimentos aleatórios
            lastRandomMove: 0
        };

        const difficultyLevels = {
            easy: {
                speed: 2,
                uncertainty: paddleHeight, // Incerteza máxima
                reactionDistance: canvas.width / 8, // Reage muito tarde
                randomMoveInterval: 2000, // Movimentos aleatórios frequentes
                predictionIterations: 100, // Poucas iterações de previsão
            },
            medium: {
                speed: 8, // Velocidade alta
                uncertainty: paddleHeight / 16, // Mínima incerteza
                reactionDistance: canvas.width * 0.75, // Reage bem cedo
                randomMoveInterval: 500, // Movimentos aleatórios menos frequentes
                predictionIterations: 5000, // Muitas iterações de previsão
                time: 1000
            },
            hard: {
                speed: 8, // Velocidade alta
                uncertainty: paddleHeight / 16, // Mínima incerteza
                reactionDistance: canvas.width * 0.75, // Reage bem cedo
                randomMoveInterval: 500, // Movimentos aleatórios menos frequentes
                predictionIterations: 5000, // Muitas iterações de previsão
                time: 1
            },
        };

        let currentDifficulty = 'easy'; // Define a dificuldade inicial

        function setDifficulty(level) {
            currentDifficulty = level;
            const settings = difficultyLevels[level];
            rightPaddle.speed = settings.speed;
            rightPaddle.uncertainty = settings.uncertainty;
            rightPaddle.reactionDistance = settings.reactionDistance;
            rightPaddle.randomMoveInterval = settings.randomMoveInterval;
        }

        const keys = {};

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        function startCountdown() {
            countdownElement.textContent = countdown;

            const countdownInterval = setInterval(() => {
                countdown--;

                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                    countdownElement.style.display = 'none';
                    gameStarted = true;
                    gameLoop();
                } else {
                    countdownElement.textContent = countdown;
                }
            }, 1000);
        }

        function updateLives() {
            const remainingLivesP1 = '🐄'.repeat(maxScore - rightScore);
            const remainingLivesP2 = '🐄'.repeat(maxScore - leftScore);
            p1LivesElement.textContent = remainingLivesP1;
            p2LivesElement.textContent = remainingLivesP2;
        }

        function checkWinner() {
            if (rightScore >= maxScore) {
                gameEnded = true;
                winnerElement.style.display = 'block';
                winnerElement.textContent = 'Player 2 Venceu! 🏆';
                return true;
            } else if (leftScore >= maxScore) {
                gameEnded = true;
                winnerElement.style.display = 'block';
                winnerElement.textContent = 'Player 1 Venceu! 🏆';
                return true;
            }
            return false;
        }

        let lastAIUpdate = 0; // Variável para armazenar o tempo da última atualização da IA

        function aiMovePaddle() {
            const currentTime = Date.now();
            let time = difficultyLevels[currentDifficulty].time;

            // Verifica se passou 1 segundo desde a última atualização
            if (currentTime - lastAIUpdate >= time) {
                const settings = difficultyLevels[currentDifficulty];

                if (ball.speedX > 0 && ball.x > rightPaddle.reactionDistance) {
                    rightPaddle.targetY = predictBallPosition(settings.predictionIterations, 0.01);

                    // Adiciona incerteza APENAS no modo easy e medium
                    if (currentDifficulty !== 'hard') {
                        rightPaddle.targetY += (Math.random() - 0.5) * 2 * rightPaddle.uncertainty;
                    }
                } else {
                    // Movimentos aleatórios enquanto espera
                    if (Date.now() - rightPaddle.lastRandomMove > rightPaddle.randomMoveInterval) {
                        rightPaddle.targetY = Math.random() * (canvas.height - paddleHeight);
                        rightPaddle.lastRandomMove = Date.now();
                    }
                }
                lastAIUpdate = currentTime; // Atualiza o tempo da última atualização
            }


            // Move a raquete em direção ao alvo (esta parte permanece fora da condição de tempo)
            let dy = rightPaddle.targetY - rightPaddle.y;
            let moveSpeed = Math.min(Math.abs(dy), rightPaddle.speed);
            rightPaddle.y += Math.sign(dy) * moveSpeed;

            rightPaddle.y = Math.max(0, Math.min(rightPaddle.y, canvas.height - paddleHeight));
        }

        function predictBallPosition(iterations, step) {
            let position = { x: ball.x, y: ball.y };
            let velocity = { x: ball.speedX, y: ball.speedY };

            for (let i = 0; i < iterations; i++) {
                position.x += velocity.x * step;
                position.y += velocity.y * step;

                if (position.y + ball.radius > canvas.height || position.y - ball.radius < 0) {
                    velocity.y *= -1;
                }

                if (position.x + ball.radius > canvas.width - paddleWidth) {
                    // Colisão com a raquete direita
                    return position.y - paddleHeight / 2; // Retorna diretamente a posição Y de colisão
                }
            }

            // Retorna a posição Y atual se não houver colisão prevista dentro das iterações
            return position.y - paddleHeight / 2;
        }

        function movePaddles() {
            if (keys['KeyW'] && leftPaddle.y > 0) {
                leftPaddle.y -= 5;
            }
            if (keys['KeyS'] && leftPaddle.y < canvas.height - paddleHeight) {
                leftPaddle.y += 5;
            }

            if (!singlePlayer) { // Modo multiplayer
                if (keys['ArrowUp'] && rightPaddle.y > 0) {
                    rightPaddle.y -= 5;
                }
                if (keys['ArrowDown'] && rightPaddle.y < canvas.height - paddleHeight) {
                    rightPaddle.y += 5;
                }
            } else { // Modo single player (IA)
                aiMovePaddle();
            }
        }


        function moveBall() {
            if (!gameStarted) return;

            ball.x += ball.speedX;
            ball.y += ball.speedY;

            if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
                ball.speedY = -ball.speedY;
            }

            let paddleHit = null; // Para rastrear qual raquete foi atingida

            if (ball.x - ball.radius < leftPaddle.x + paddleWidth && ball.y > leftPaddle.y && ball.y < leftPaddle.y + paddleHeight) {
                paddleHit = leftPaddle;
            } else if (ball.x + ball.radius > rightPaddle.x && ball.y > rightPaddle.y && ball.y < rightPaddle.y + paddleHeight) {
                paddleHit = rightPaddle;
            }

            if (paddleHit) {
                ball.speedX = -ball.speedX;

                // Aumenta a velocidade a cada batida
                let speedIncrement = 1.5; // Valor do incremento de velocidade
                let currentSpeed = Math.sqrt(ball.speedX * ball.speedX + ball.speedY * ball.speedY);
                let newSpeed = currentSpeed + speedIncrement;

                // Mantém a direção, mas altera a magnitude da velocidade
                ball.speedX = (ball.speedX / currentSpeed) * newSpeed;
                ball.speedY = (ball.speedY / currentSpeed) * newSpeed;
            }

            if (ball.x + ball.radius > canvas.width) {
                leftScore++;
                resetBall();
            } else if (ball.x - ball.radius < 0) {
                rightScore++;
                resetBall();
            }
        }

        function startPointCountdown() {
            isPointCountdownActive = true;
            pointCountdown = 3;
            pointCountdownElement.style.display = 'flex';
            pointCountdownElement.textContent = pointCountdown;

            const pointCountdownInterval = setInterval(() => {
                pointCountdown--;

                if (pointCountdown <= 0) {
                    clearInterval(pointCountdownInterval);
                    pointCountdownElement.style.display = 'none';
                    isPointCountdownActive = false;
                    gameStarted = true;
                } else {
                    pointCountdownElement.textContent = pointCountdown;
                }
            }, 1000);
        }

        function resetBall() {
            ballSpeedMultiplier += 0.4;
            ball.x = canvas.width / 2;

            // Define a posição Y inicial da bola aleatoriamente
            ball.y = Math.random() * (canvas.height - 2 * ball.radius) + ball.radius;  // Mantém a bola dentro dos limites da tela

            ball.speedX = -ball.speedX;
            ball.speedY = (Math.random() > 0.5 ? initialBallSpeed : -initialBallSpeed) * ballSpeedMultiplier;
            ball.speedX = Math.sign(ball.speedX) * initialBallSpeed * ballSpeedMultiplier;

            leftPaddle.y = initialPaddlePositions.left;
            rightPaddle.y = initialPaddlePositions.right;

            updateLives();
            if (!checkWinner()) {
                gameStarted = false;
                startPointCountdown();
            }
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#fff';
            ctx.fillRect(leftPaddle.x, leftPaddle.y, paddleWidth, paddleHeight);

            ctx.fillRect(rightPaddle.x, rightPaddle.y, paddleWidth, paddleHeight);

            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
        }

        function gameLoop() {
            if (!gameEnded) {
                if (!isPointCountdownActive) {
                    movePaddles();
                    moveBall();
                }
                draw();
                requestAnimationFrame(gameLoop);
            }
        }
        setDifficulty('medium'); // Define a dificuldade como média
        setSinglePlayer(true); // true para single player, false para multiplayer
        startCountdown();
    </script>

    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</body>

</html>